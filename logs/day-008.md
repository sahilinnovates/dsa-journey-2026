# Day 008 - (08 Feb 2026)

## âœ… Problems Solved: 1

---

### 1) Problem: Find Eventual Safe States

**A node is terminal if it has no outgoing edges. A node is safe if every possible path starting from it leads to a terminal node. Return all safe nodes in ascending order.**
**Approach:**

* Use **DFS with cycle detection** similar to detecting cycles in a directed graph.
* Maintain two arrays:

  * `vis[]` to mark visited nodes.
  * `pathVis[]` to mark nodes in the current DFS path.
* If a cycle is detected, nodes in that path are not safe.
* Nodes that complete DFS without encountering a cycle are safe and added to the result.

**Time Complexity:** `O(V+E)`
**Space Complexity:** `O(V)`

**Code:**

```cpp
class Solution{
public:
    bool dfs(vector<int> adj[], vector<int>& vis, vector<int>& pathVis, vector<int>& ans, int nd){
        vis[nd]=1;
        pathVis[nd]=1;
        for(int node: adj[nd]){
            if(!vis[node]){
                if(!dfs(adj,vis,pathVis,ans,node)) return false;
            } else if(pathVis[node]==1) return false;
        }
        ans.push_back(nd);
        pathVis[nd]=0;
        return true;
    }
    vector<int> eventualSafeNodes(int V, vector<int> adj[]){
        vector<int> ans;
        vector<int> vis(V,0);
        vector<int> pathVis(V,0);
        for(int i=0; i<V; i++){
            if(!vis[i]){
                dfs(adj,vis,pathVis,ans,i);
            }
        }
        sort(ans.begin(),ans.end());
        return ans;
    }
};
```
