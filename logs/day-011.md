## Day 011 — 11 Feb 2026

### Problem 1: Course Schedule I

**Problem Statement**
There are a total of `N` tasks labeled from `0` to `N-1`. Given an array `arr` where `arr[i] = [a, b]` indicates that you must take course `b` first if you want to take course `a`. Determine if it is possible to finish all tasks.

---

### Approach

* Converted the prerequisites list into an adjacency list.
* Treated the problem as **cycle detection in a directed graph**.
* Used **DFS traversal** with two arrays:

  * `vis[]` → tracks visited nodes.
  * `pathVis[]` → tracks nodes in the current recursion stack.
* If a node is found already in the current DFS path, a cycle exists.
* If a cycle exists → not possible to finish all courses.
* If no cycle exists → all courses can be completed.

---

### Time Complexity

* **O(N + E)**
  Where `N` = number of courses, `E` = number of prerequisite relations.

### Space Complexity

* **O(N + E)**
  For adjacency list and recursion stack.

---

### Code

```cpp
class Solution{
public:
    bool dfs(vector<int> adj[], vector<int>& vis, vector<int>& pathVis, int nd){
        vis[nd]=1;
        pathVis[nd]=1;
        for(int node: adj[nd]){
            if(vis[node]==0){
                if(dfs(adj,vis,pathVis,node)){
                    pathVis[nd]=0;
                    return true;
                }
            } else if(pathVis[node]==1) return true;
        }
        pathVis[nd]=0;
        return false;
    }
    bool canFinish(int N, vector<vector<int>> arr) {
        int r = arr.size();
        vector<int> adj[N];
        for(int i=0; i<r; i++){
            int x = arr[i][0];
            int y = arr[i][1];
            adj[y].push_back(x);
        }
        vector<int> vis(N,0);
        vector<int> pathVis(N,0);
        for(int i=0; i<N; i++){
            if(!vis[i]){
                if(dfs(adj,vis,pathVis,i)) return false;
            }
        }
        return true;
    }
};
```