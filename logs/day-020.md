# Day 020 - (20 Feb 2026)

## ✅ Problems Solved: 1

---

### 1) Problem: Print Shortest Path

**Given a weighted undirected graph with `n` vertices and `m` edges, find the shortest path from vertex `1` to vertex `n`. If no path exists, return `-1`. Otherwise, return the total weight followed by the path.**

**Approach:**

* Built an adjacency list for the weighted undirected graph.
* Applied **Dijkstra’s Algorithm** using a priority queue to compute shortest distances.
* Maintained a `parent` array to reconstruct the shortest path.
* Updated parent whenever a shorter distance was found during relaxation.
* After Dijkstra finishes, reconstructed the path from node `n` back to `1` using the parent array.
* Reversed the path and inserted the total shortest distance at the beginning.

**Time Complexity:** `O(E log V)`
**Space Complexity:** `O(V + E)`

**Code:**

```cpp
class Solution{
public:
    vector<int> shortestPath(int n, int m, vector<vector<int>> &edges) {
        vector<vector<pair<int,int>>> adj(n+1);
        for(int i=0; i<m; i++){
            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});
            adj[edges[i][1]].push_back({edges[i][0],edges[i][2]});
        }
        vector<int> parent(n+1);
        for(int i=0; i<n+1; i++) parent[i]=i;
        vector<int> dist(n+1,1e9);
        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;
        pq.push({0,1});
        dist[1]=0;
        parent[1]=1;
        while(!pq.empty()){
            int d = pq.top().first;
            int nd = pq.top().second;
            pq.pop();
            if(d > dist[nd]) continue;
            for(auto it: adj[nd]){
                int node = it.first;
                int dt = it.second;
                if(d + dt < dist[node]){
                    dist[node] = d + dt;
                    pq.push({dist[node], node});
                    parent[node] = nd;
                }
            }
        }
        if(dist[n] == 1e9) return {-1};
        vector<int> ans;
        int node = n;
        while(node != 1){
            ans.push_back(node);
            node = parent[node];
        }
        ans.push_back(node);
        reverse(ans.begin(), ans.end());
        ans.insert(ans.begin(), dist[n]);
        return ans;
    }
};
```
