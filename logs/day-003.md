# Day 003 - (03 Feb 2026)

## ✅ Problems Solved: 2

---

### 1) Problem: Detect a Cycle in an Undirected Graph

**Determine if the given undirected graph contains any cycle.**
**Approach:**

* **BFS (parent tracking):**

  * Start BFS from every unvisited node (handles disconnected graphs).
  * Store `(parent, node)` in queue.
  * If a visited neighbor is found that is not the parent → cycle exists.
* **DFS (recursive parent tracking):**

  * DFS from each unvisited node.
  * Pass parent in recursion.
  * If a visited neighbor is not the parent → cycle exists.

**Time Complexity:** `O(V+E)`
**Space Complexity:** `O(V)`

**Code (BFS):**

```cpp
class Solution{
public:
    bool isCycle(int V, vector<int> adj[]) {
        queue<pair<int,int>> q;
        vector<int> vis(V,0);
        for(int i=0; i<V; i++){
            if(vis[i]==0){
                q.push({-1,i});
                vis[i]=1;
                while(!q.empty()){
                    int p = q.front().first;
                    int nd = q.front().second;
                    q.pop();
                    for(int node : adj[nd]){
                        if(node==p) continue;
                        if(vis[node]==0){
                            q.push({nd,node});
                            vis[node]=1;
                        } else return true;
                    }
                }
            }
        }
        return false;
    }
};
```

**Code (DFS):**

```cpp
class Solution{
public:
    bool dfs(vector<int> adj[], vector<int>& vis, int nd, int p){
        vis[nd]=1;
        for(int node: adj[nd]){
            if(node==p) continue;
            if(vis[node]==0){
                if(dfs(adj,vis,node,nd)) return true;
            } else return true;
        }
        return false;
    }
    bool isCycle(int V, vector<int> adj[]) {
        queue<pair<int,int>> q;
        vector<int> vis(V,0);
        for(int i=0; i<V; i++){
            if(vis[i]==0){
                if(dfs(adj,vis,i,-1)) return true;
            }
        }
        return false;
    }
};
```

---

### 2) Problem: Bipartite Graph

**Determine if the graph is bipartite (can be colored using 2 colors such that no adjacent nodes share the same color).**
**Approach:**

* **BFS coloring:**

  * Use `col[]` initialized to `-1`.
  * Start BFS from each uncolored node.
  * Assign alternate colors to neighbors.
  * If any edge connects same-colored nodes → not bipartite.
* **DFS coloring:**

  * DFS from each uncolored node.
  * Assign color and recursively assign opposite color to neighbors.
  * If a conflict is found → not bipartite.

**Time Complexity:** `O(V+E)`
**Space Complexity:** `O(V)`

**Code (BFS):**

```cpp
class Solution{
public:
    bool isBipartite(int V, vector<int> adj[])  {
        vector<int> col(V,-1);
        queue<int> q;
        for(int i=0; i<V; i++){
            if(col[i]==-1){
                q.push(i);
                col[i]=0;
                while(!q.empty()){
                    int nd = q.front();
                    int c = col[nd];
                    q.pop();
                    for(int node: adj[nd]){
                        if(col[node]==-1){
                            q.push(node);
                            col[node] = (!c);
                        } else if(col[node]==c) return false;
                    }
                }
            }
        }
        return true;
    }
};
```

**Code (DFS):**

```cpp
class Solution{
public:
    bool dfs(vector<int> adj[], vector<int>& col, int nd, int c){
        col[nd]=c;
        for(int node: adj[nd]){
            if(col[node]==-1){
                if(!dfs(adj,col,node,(!c))) return false;
            } else if(col[node]==c) return false;
        }
        return true;        
    }
    bool isBipartite(int V, vector<int> adj[])  {
        vector<int> col(V,-1);
        queue<int> q;
        for(int i=0; i<V;  i++){
            if(col[i]==-1){
                if(!dfs(adj,col,i,0)) return false;
            }
        }
        return true;
    }
};
```
