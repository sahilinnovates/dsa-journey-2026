# Day 021 - (21 Feb 2026)

## âœ… Problems Solved: 1

---

### 1) Problem: Shortest Distance in a Binary Maze

**Given an `n x m` grid where each cell contains either 0 or 1, find the shortest path from a source cell to a destination cell. Movement is allowed only through cells having value `1` in four directions. If the destination is unreachable, return -1.**

**Approach:**

* Observed that all moves have **unit weight**, so applied **BFS**.
* Used a queue storing `{distance, {row, col}}`.
* Maintained a visited matrix to avoid re-processing cells.
* Started BFS from the source cell.
* For each cell, explored all 4 directions.
* If destination is reached, returned the current distance + 1.
* If BFS completes without reaching destination, returned -1.

**Time Complexity:** `O(n*m)`
**Space Complexity:** `O(n*m)`

**Code:**

```cpp
class Solution{
public:
    int shortestPath(vector<vector<int>> &grid, pair<int, int> source, pair<int, int> destination) {
        if(source==destination) return 0;
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> vis(n,vector<int>(m,0));
        queue<pair<int,pair<int,int>>> q;
        q.push({0,source});
        vis[source.first][source.second]=1;
        vector<int> row = {-1,0,1,0};
        vector<int> col = {0,1,0,-1};
        while(!q.empty()){
            int d = q.front().first;
            int r = q.front().second.first;
            int c = q.front().second.second;
            q.pop();
            for(int i=0; i<4; i++){
                int nr = r+row[i];
                int nc = c+col[i];
                if(nr>=0 && nc>=0 && nr<n && nc<m && grid[nr][nc]==1 && !vis[nr][nc]){
                    vis[nr][nc]=1;
                    if(make_pair(nr,nc)==destination) return d+1;
                    q.push({d+1,{nr,nc}});
                }
            }
        }
        return -1;
    }
};
```
