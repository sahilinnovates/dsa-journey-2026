## Day 012 — 12 Feb 2026

### Problem 1: Course Schedule II

**Problem Statement**
There are a total of `N` tasks labeled from `0` to `N-1`. Given an array `arr` where `arr[i] = [a, b]` indicates that you must take course `b` first if you want to take course `a`. Return the correct order of tasks to finish all courses.
If no such ordering exists, return an empty array.

---

### Approach

* Built an adjacency list from the prerequisite pairs.
* Treated the problem as **Topological Sorting of a Directed Graph**.
* Used **Kahn’s Algorithm (BFS-based approach)**:

  * Calculated indegree of every node.
  * Added nodes with indegree `0` to queue.
  * Processed nodes and reduced indegree of neighbors.
* If the resulting topological order contains all `N` nodes → valid ordering exists.
* If not → cycle exists → return empty array.

---

### Time Complexity

* **O(N + E)**
  Where `N` = number of courses, `E` = number of prerequisite relations.

### Space Complexity

* **O(N + E)**
  For adjacency list, indegree array, and queue.

---

### Code

```cpp
class Solution {
  public:
    vector<int> topoSort(int V, vector<int> adj[]){
        vector<int> indeg(V,0);
        queue<int> q;
        vector<int> ans;
        for(int i=0; i<V; i++){
            for(int j: adj[i]){
                indeg[j]++;
            }
        }
        for(int i=0; i<V; i++){
            if(indeg[i]==0) q.push(i);
        }
        while(!q.empty()){
            int nd = q.front();
            q.pop();
            ans.push_back(nd);
            for(int node: adj[nd]){
                if(--indeg[node]==0) q.push(node);
            }
        }
        return ans;
    }
    vector <int> findOrder(int N, vector < vector < int >> arr) {
        int r = arr.size();
        vector<int> adj[N];
        for(int i=0; i<r; i++){
            int x = arr[i][0];
            int y = arr[i][1];
            adj[y].push_back(x);
        }
        vector<int> ans = topoSort(N,adj);
        if(ans.size()!=N) return {};
        return ans;
    }
};
```