## Day 014 — 14 Feb 2026

### Problem 1: Word Ladder I

**Problem Statement**
Given `beginWord`, `endWord`, and a dictionary `wordList`, return the length of the shortest transformation sequence from `beginWord` to `endWord` such that:

* Only one letter can be changed at a time.
* Each transformed word must exist in `wordList`.
* `beginWord` does not need to be in `wordList`.
* The final word must be `endWord`.

Return `0` if no such transformation exists.

---

### Approach

* Stored all dictionary words in an `unordered_set` for O(1) lookup.
* Used **BFS traversal** because we need the shortest transformation sequence.
* Pushed `{word, level}` into queue.
* For each word:

  * Tried changing every character position.
  * Replaced with letters from `'a'` to `'z'`.
  * If new word exists in set → push into queue and remove from set.
* The first time we reach `endWord`, we return the level.

---

### Why BFS?

BFS guarantees the first time we reach `endWord` is the shortest transformation path.

---

### Time Complexity

* **O(N * L * 26)**
  Where:

  * `N` = number of words
  * `L` = length of each word

### Space Complexity

* **O(N)**
  For set and queue.

---

### Code

```cpp
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        int n = wordList.size();
        int s = beginWord.size();
        unordered_set<string> st;
        for(string s: wordList){
            st.insert(s);
        }
        if(st.find(endWord)==st.end()) return 0;
        queue<pair<string,int>> q;
        q.push({beginWord,1});
        while(!q.empty()){
            string wrd = q.front().first;
            int l = q.front().second;
            q.pop();
            if(wrd==endWord) return l;
            for(int i=0; i<s; i++){
                string nwrd = wrd;
                for(int j=0; j<=26; j++){
                    nwrd[i]=('a'+j);
                    if(st.find(nwrd)!=st.end()){
                        q.push({nwrd,(l+1)});
                        st.erase(nwrd);
                    }
                }
            }
        }
        return 0;
    }
};
```
