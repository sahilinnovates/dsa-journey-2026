## Day 017 â€” 17 Feb 2026

### Problem 1: Shortest Path in Undirected Graph (Unit Weights)

**Problem Statement**
Given an undirected graph with `N` vertices and `M` edges (unit weight), find the shortest distance from source vertex `0` to all other vertices.
If a vertex is unreachable, return `-1` for that vertex.

---

### Approach

* Built an adjacency list for the undirected graph.
* Since all edges have **unit weight**, used **BFS** instead of Dijkstra.
* Initialized distance array with `-1`.
* Started BFS from node `0`.
* For each neighbor:

  * If unvisited (`dist[node] == -1`), update distance as `d + 1`.
  * Push into queue for further exploration.

---

### Why BFS Works Here

In graphs with **unit weights**, BFS guarantees shortest path because:

* Nodes are explored level-by-level.
* The first time we reach a node is via the shortest path.

---

### Time Complexity

* **O(N + M)**
  Each node and edge is processed once.

### Space Complexity

* **O(N + M)**
  For adjacency list and queue.

---

### Code

```cpp
class Solution {
  public:
    vector<int> shortestPath(vector<vector<int>>& edges, int N,int M){
      vector<int> adj[N];
      for(int i=0; i<M; i++){
        adj[edges[i][0]].push_back(edges[i][1]);
        adj[edges[i][1]].push_back(edges[i][0]);
      }
      vector<int> dist(N,-1);
      queue<pair<int,int>> q;
      q.push({0,0});
      dist[0]=0;
      while(!q.empty()){
        int nd = q.front().first;
        int d = q.front().second;
        q.pop();
        for(int node: adj[nd]){
          if(dist[node]==-1 || dist[node]>(d+1)){
            dist[node]=d+1;
            q.push({node,d+1});
          }
        }
      }
      return dist;
    }
};
```