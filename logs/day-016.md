## Day 016 - 16 Feb 2026

### Problem 1: Shortest Path in DAG

**Problem Statement**
Given a Directed Acyclic Graph (DAG) with `N` vertices and `M` weighted edges, find the shortest path from source vertex `0` to all other vertices.
If a vertex is unreachable, return `-1` for that vertex.

---

### Approach

* Built an adjacency list storing `{node, weight}` pairs.
* Performed **Topological Sort using DFS**.
* Initialized distance array with `-1`.
* Set `dist[0] = 0` since source is vertex `0`.
* Processed nodes in topological order:

  * For each edge `(u → v)` with weight `w`:

    * If `dist[u]` is known, update `dist[v]` using relaxation:
      `dist[v] = min(dist[v], dist[u] + w)`.
* Nodes that remain `-1` are unreachable.

---

### Why This Works

In a DAG, processing nodes in topological order guarantees that when we process a node, all shortest paths leading to it have already been finalized.
This avoids the need for Dijkstra’s algorithm.

---

### Time Complexity

* **O(N + M)**

  * Topological sort: O(N + M)
  * Edge relaxation: O(M)

### Space Complexity

* **O(N + M)**
  For adjacency list, stack, and distance array.

---

### Code

```cpp
class Solution {
    public:
    void dfs(vector<pair<int,int>> adj[], vector<int>& vis, stack<int>& st, int v){
        vis[v]=1;
        for(auto it: adj[v]){
            if(!vis[it.first]){
                dfs(adj,vis,st,it.first);
            }
        }
        st.push(v);
    }
    vector <int> shortestPath(int N, int M, vector<vector<int>> & edges) {
        vector<pair<int,int>> adj[N];
        for(int i=0; i<M; i++){
            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});
        }
        stack<int> st;
        vector<int> vis(N,0);
        for(int i=0; i<N; i++){
            if(!vis[i]){
                dfs(adj,vis,st,i);
            }
        }
        vector<int> dist(N,-1);
        dist[0]=0;
        while(!st.empty()){
            int nd = st.top();
            int d = dist[nd];
            st.pop();
            if(d==-1) continue;
            for(auto it: adj[nd]){
                int newd = d + it.second;
                if(dist[it.first]==-1 || dist[it.first]>newd){
                    dist[it.first]=newd;
                }
            }
        }
        return dist;
    }
};
```