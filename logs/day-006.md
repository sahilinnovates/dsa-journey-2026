# Day 006 - (06 Feb 2026)

## ✅ Problems Solved: 1

---

### 1) Problem: Topological Sort

**In topological sorting, node `u` always appears before node `v` if there is a directed edge from `u` to `v` (`u → v`).**
**Approach:**

* **DFS-based approach:**

  * Perform DFS from each unvisited node.
  * After visiting all adjacent nodes, push the current node onto a stack.
  * Pop elements from the stack to get the topological order.
* **BFS-based approach (Kahn’s Algorithm):**

  * Compute indegree for all vertices.
  * Push all nodes with indegree `0` into a queue.
  * Repeatedly remove nodes from the queue, reduce indegree of neighbors, and add them when indegree becomes `0`.

**Time Complexity:** `O(V+E)`
**Space Complexity:** `O(V)`

**Code (DFS):**

```cpp
class Solution{
public:
    void dfs(vector<int> adj[], vector<int>& vis, stack<int>& st, int nd){
        vis[nd]=1;
        for(int node: adj[nd]){
            if(!vis[node]) dfs(adj,vis,st,node);
        }
        st.push(nd);
    }
    vector<int> topoSort(int V, vector<int> adj[]){
        vector<int> vis(V,0);
        stack<int> st;
        for(int i=0; i<V; i++){
            if(!vis[i]){
                dfs(adj,vis,st,i);
            }
        }
        vector<int> ans;
        while(!st.empty()){
            ans.push_back(st.top());
            st.pop();
        }
        return ans;
    }
};
```

**Code (BFS – Kahn’s Algorithm):**

```cpp
class Solution{
public:
    vector<int> topoSort(int V, vector<int> adj[]){
        vector<int> indeg(V,0);
        queue<int> q;
        vector<int> ans;
        for(int i=0; i<V; i++){
            for(int j: adj[i]){
                indeg[j]++;
            }
        }
        for(int i=0; i<V; i++){
            if(indeg[i]==0) q.push(i);
        }
        while(!q.empty()){
            int nd = q.front();
            q.pop();
            ans.push_back(nd);
            for(int node: adj[nd]){
                if(--indeg[node]==0) q.push(node);
            }
        }
        return ans;
    }
};
```
