## Day 015 — 15 Feb 2026

### Problem 1: Word Ladder II

**Problem Statement**
Given two distinct words `startWord` and `targetWord`, and a list `wordList` of unique words of equal lengths, return **all shortest transformation sequences** from `startWord` to `targetWord`.
Each transformation:

* Changes only one letter at a time.
* Must result in a word present in `wordList`.

---

### Approach

* Stored all words in an `unordered_set` for fast lookup.
* Used **BFS** to ensure shortest path discovery.
* Instead of storing just `{word, level}`, stored the **entire path vector** in the queue.
* Processed level-by-level to guarantee shortest sequences.
* Used a `used` set to remove words only after finishing the current BFS level.
* Once the first valid sequence is found:

  * Continue collecting sequences of the same length.
  * Stop BFS after finishing that level.

---

### Key Idea

* Word Ladder I → shortest path length.
* Word Ladder II → store complete paths during BFS.
* Removing words level-by-level prevents longer paths from interfering with shortest ones.

---

### Time Complexity

* Exponential in worst case due to storing full paths.
* Practical complexity depends on branching factor and word length.

### Space Complexity

* High due to storing multiple transformation paths in queue.

---

### Code

```cpp
class Solution{
public:
    vector<vector<string>> findSequences(string beginWord, string endWord, vector<string> &wordList){
        unordered_set<string> st(wordList.begin(),wordList.end());
        vector<vector<string>> ans;
        queue<vector<string>> q;
        q.push({beginWord});
        unordered_set<string> used;
        while(!q.empty()){
            int s = q.size();
            for(int i=0; i<s; i++){
                vector<string> v = q.front();
                q.pop();
                string wrd = v.back();
                if(wrd==endWord){
                    if(ans.empty()){
                        ans.push_back(v);
                    } else if(ans.back().size()==v.size()){
                        ans.push_back(v);
                    }
                }
                for(int i=0; i<wrd.length(); i++){
                    char org = wrd[i];
                    for(int j=0; j<26; j++){
                        wrd[i]=('a'+j);
                        if(st.find(wrd)!=st.end()){
                            v.push_back(wrd);
                            q.push(v);
                            used.insert(wrd);
                            v.pop_back();
                        }
                    }
                    wrd[i]=org;
                }
            }
            for(auto it: used){
                st.erase(it);
            }
            used.clear();
            if(!ans.empty()) break;
        }
        return ans;
    }
};
```