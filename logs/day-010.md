## Day 010 — 10 Feb 2026

### Problem Revisited: Find Eventual Safe States (BFS / Kahn’s Algorithm)

**Problem Statement**
A node is a *terminal node* if it has no outgoing edges. A node is *safe* if every possible path starting from that node leads to a terminal node.

---

### Approach Used

* Reversed the graph (edges reversed)
* Computed indegree of each node in the reversed graph
* Applied **Kahn’s Algorithm (BFS-based topological sort)**
* Nodes that get processed are safe nodes

---

### Key Idea

Nodes involved in cycles will never reach indegree 0 in the reversed graph, so they are automatically excluded.

---

### Complexity

* **Time Complexity:** O(V + E)
* **Space Complexity:** O(V + E)

---

### Code

```cpp
class Solution{
public:
    vector<int> topoSort(int V, vector<int> adjList[]){
        vector<int> indeg(V,0);
        queue<int> q;
        vector<int> ans;
        for(int i=0; i<V; i++){
            for(int j: adjList[i]){
                indeg[j]++;
            }
        }
        for(int i=0; i<V; i++){
            if(indeg[i]==0) q.push(i);
        }
        while(!q.empty()){
            int nd = q.front();
            q.pop();
            ans.push_back(nd);
            for(int node: adjList[nd]){
                if(--indeg[node]==0) q.push(node);
            }
        }
        return ans;
    }
    vector<int> eventualSafeNodes(int V, vector<int> adj[]){
        vector<int> adjList[V];
        for(int i=0; i<V; i++){
            for(int j: adj[i]){
                adjList[j].push_back(i);
            }
        }
        vector<int> ans = topoSort(V,adjList);
        sort(ans.begin(),ans.end());
        return ans;
    }
};
```

---

### Learning Takeaway

* Same problem → different perspective (DFS vs BFS)
* Strong connection between:

  * Cycle detection
  * Topological sorting
  * Safe states in directed graphs

---

**Status:** ✅ Revisited & strengthened graph fundamentals
