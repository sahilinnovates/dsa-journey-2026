# Day 005 - (05 Feb 2026)

## ✅ Problems Solved: 3

---

### 1) Problem: Inorder Traversal

**Given the root of a binary tree, return its inorder traversal (Left → Root → Right).**
**Approach:**

* Use recursive DFS traversal.
* Visit left subtree, then current node, followed by right subtree.

**Time Complexity:** `O(n)`
**Space Complexity:** `O(n)`

**Code:**

```cpp
class Solution{
	public:
		void traverse(vector<int>& ans, TreeNode* nd){
			if(nd==NULL) return;
			traverse(ans,nd->left);
			ans.push_back(nd->data);
			traverse(ans,nd->right);
		}
		vector<int> inorder(TreeNode* root){
	        vector<int> ans;
			traverse(ans,root);
			return ans;
		}
};
```

---

### 2) Problem: Preorder Traversal

**Given the root of a binary tree, return its preorder traversal (Root → Left → Right).**
**Approach:**

* Use recursive DFS traversal.
* Process current node before traversing left and right subtrees.

**Time Complexity:** `O(n)`
**Space Complexity:** `O(n)`

**Code:**

```cpp
class Solution{
	public:
		void traverse(vector<int>& ans, TreeNode* nd){
			if(nd==NULL) return;
			ans.push_back(nd->data);
			traverse(ans,nd->left);
			traverse(ans,nd->right);
		}
		vector<int> preorder(TreeNode* root){
			vector<int> ans;
			traverse(ans,root);
			return ans;
		}
};
```

---

### 3) Problem: Postorder Traversal

**Given the root of a binary tree, return its postorder traversal (Left → Right → Root).**
**Approach:**

* Use recursive DFS traversal.
* Traverse left and right subtrees before processing the current node.

**Time Complexity:** `O(n)`
**Space Complexity:** `O(n)`

**Code:**

```cpp
class Solution{
	public:
		void traverse(vector<int>& ans, TreeNode* nd){
			if(nd==NULL) return;
			traverse(ans,nd->left);
			traverse(ans,nd->right);
			ans.push_back(nd->data);
		}
		vector<int> postorder(TreeNode* root){
			vector<int> ans;
			traverse(ans,root);
			return ans;
		}
};
```
