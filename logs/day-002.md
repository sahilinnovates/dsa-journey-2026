# Day 002 - (02 Feb 2026)

## âœ… Problems Solved: 2

---

### 1) Problem: Distance of Nearest Cell Having 1

**Find the distance of the nearest 1 in the grid for each cell using Manhattan distance: `|i1 - i2| + |j1 - j2|`.**
**Approach:**

* Use **multi-source BFS** by pushing all cells containing `1` into the queue with distance `0`.
* Maintain a `res` grid initialized with `-1` to mark unvisited cells.
* Expand in 4 directions and assign the first time reached distance (guaranteed minimum).

**Time Complexity:** `O(n*m)`
**Space Complexity:** `O(n*m)`

**Code:**

```cpp
class Solution{
public:
    vector<vector<int>> nearest(vector<vector<int>> grid){
        int n = grid.size();
        int m = grid[0].size();
        vector<vector<int>> res(n, vector<int>(m,-1));
        queue<pair<pair<int,int>,int>> q;
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1){
                    res[i][j]=0;
                    q.push({{i,j},0});
                }
            }
        }
        int row[]={-1,0,1,0};
        int col[]={0,1,0,-1};
        while(!q.empty()){
            int r = q.front().first.first;
            int c = q.front().first.second;
            int d = q.front().second;
            q.pop();
            for(int i=0; i<4; i++){
                int nr = r + row[i];
                int nc = c + col[i];
                if(nr>=0 && nc>=0 && nr<n && nc<m && res[nr][nc]==-1){
                    res[nr][nc]=d+1;
                    q.push({{nr,nc},d+1});
                }
            }
        }
        return res;
    }
};
```

---

### 2) Problem: Number of Distinct Islands

**Count the number of distinct islands in a binary grid. Two islands are considered the same only if their shapes match exactly (no rotation/reflection).**
**Approach:**

* Run DFS for every unvisited land cell (`1`) to capture the island.
* Store each island shape as a list of **relative coordinates** from the base cell `(bi, bj)`.
* Insert the shape vector into a `set` to keep only unique island shapes.

**Time Complexity:** `O(n*m * log S)`
**Space Complexity:** `O(n*m)`

**Code:**

```cpp
class Solution
{
public:
    void dfs(vector<vector<int>>& grid, vector<vector<int>>& vis, vector<pair<int,int>>& v, vector<int>& row, vector<int>& col, int n, int m, int bi, int bj, int x, int y){
        vis[x][y]=1;
        v.push_back({x-bi,y-bj});
        for(int i=0; i<4; i++){
            int nx = x+row[i];
            int ny = y+col[i];
            if(nx>=0 && ny>=0 && nx<n && ny<m && grid[nx][ny]==1 && vis[nx][ny]==0){
                dfs(grid,vis,v,row,col,n,m,bi,bj,nx,ny);
            }
        }
    }
    int countDistinctIslands(vector<vector<int>> &grid){
        int n = grid.size();
        int m = grid[0].size();
        set<vector<pair<int,int>>> st;
        vector<vector<int>> vis(n,vector<int>(m,0));
        vector<int> row = {-1,0,1,0};
        vector<int> col = {0,1,0,-1};
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                if(grid[i][j]==1 && vis[i][j]==0){
                    vector<pair<int,int>> v;
                    dfs(grid,vis,v,row,col,n,m,i,j,i,j);
                    st.insert(v);
                } 
            }
        }
        return st.size();
    }
};
```
